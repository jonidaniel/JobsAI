"""
Generator Agent - Cover Letter Document Generation.

This module contains the GeneratorAgent class, which generates personalized
cover letter documents in Word (.docx) format. The agent uses an LLM to write
cover letter content based on candidate profiles, job analyses, and selected
writing styles.

The generated documents include:
- Contact information placeholders
- Date and recipient placeholders
- LLM-generated cover letter body
- Signature section
"""

import os
import logging
from datetime import datetime
from typing import Union, List, Any

from docx import Document
from docx.enum.text import WD_ALIGN_PARAGRAPH

from jobsai.config.paths import COVER_LETTER_PATH
from jobsai.config.prompts import (
    GENERATOR_SYSTEM_PROMPT as SYSTEM_PROMPT,
    GENERATOR_USER_PROMPT as USER_PROMPT,
)

from jobsai.utils.llms import call_llm
from jobsai.utils.normalization import normalize_text

logger = logging.getLogger(__name__)


class GeneratorAgent:
    """Agent responsible for generating personalized cover letter documents.

    Creates Word documents (.docx) with professionally formatted cover letters
    tailored to specific job positions. Uses an LLM to generate the cover letter
    content based on candidate profiles, job analyses, and selected writing styles.

    The documents are formatted as standard business letters with placeholders
    for contact information, recipient details, and signature that users can
    fill in manually before sending.

    Args:
        timestamp (str): Backend-wide timestamp for consistent file naming.
            Format: YYYYMMDD_HHMMSS (e.g., "20250115_143022")
    """

    def __init__(self, timestamp: str) -> None:
        self.timestamp: str = timestamp

    # ------------------------------
    # Public interface
    # ------------------------------
    def generate_letters(
        self,
        job_analysis: str,
        profile: str,
        style: Union[str, list[str]],
        num_letters: int = 1,
    ) -> List[Document]:
        """Generate personalized cover letter documents for multiple job applications.

        Creates Word documents with professionally formatted cover letters tailored
        to specific job positions. Generates one cover letter per job in the analysis,
        up to the specified number. Each cover letter content is generated by an LLM
        based on the candidate profile, individual job analysis, and selected writing style(s).

        Args:
            job_analysis (str): Job analysis text containing cover letter writing
                instructions for multiple jobs, generated by AnalyzerAgent. Jobs are
                separated by "---" delimiters. Each job section includes:
                - Job details (title, company, location, score)
                - Matched and missing skills
                - Personalized cover letter writing instructions
            profile (str): Candidate profile text describing skills, experience,
                and professional characteristics.
            style (str | list[str]): Writing style/tone for the cover letters.
                Can be a single string or an array of 1-2 style strings.
                Options:
                - "Professional": Clear, respectful, concise tone
                - "Friendly": Warm, positive but professional tone
                - "Confident": Confident, proactive tone without arrogance
                - "Funny": Humorous, light-hearted tone
                If array, styles are combined (e.g., ["Professional", "Friendly"]).
                Defaults to "Professional" if style not recognized.
            num_letters (int): Number of cover letters to generate (1-10).
                Defaults to 1 for backward compatibility.

        Returns:
            List[Document]: List of python-docx Document objects, one per job.
                Each document is also saved to disk at:
                {COVER_LETTER_PATH}/{timestamp}_cover_letter_{index}.docx

        Note:
            The job_analysis text is parsed to extract individual job sections.
            Each job section (separated by "---" lines) is used to generate
            a separate cover letter. If fewer jobs are in the analysis than
            num_letters, only available jobs are processed.
        """

        # Handle style as either string or array
        # Frontend now sends array, but handle both for backward compatibility
        if isinstance(style, list):
            # If array, use first style (or combine if needed)
            # For now, use first style; could be enhanced to combine styles
            style_str = style[0] if len(style) > 0 else "Professional"
        else:
            style_str = style or "Professional"

        # Build the system prompt
        # Map style names to tone instructions for the LLM
        tone_instructions = {
            "Professional": "Write in a clear, respectful, concise, professional tone. Use well-structured paragraphs. Avoid exaggerations.",
            "Friendly": "Write in a warm, positive tone but keep it professional.",
            "friendly": "Write in a warm, positive tone but keep it professional.",  # Backward compatibility
            "Confident": "Write with a confident, proactive tone without sounding arrogant.",
            "confident": "Write with a confident, proactive tone without sounding arrogant.",  # Backward compatibility
            "Funny": "Write with a humorous, light-hearted tone while remaining professional.",
            "funny": "Write with a humorous, light-hearted tone while remaining professional.",  # Backward compatibility
        }
        base_style = tone_instructions.get(style_str, tone_instructions["Professional"])
        system_prompt = SYSTEM_PROMPT.format(base_style=base_style)

        # Parse job_analysis to extract individual job sections
        # Jobs are separated by lines of dashes ("---" or "-" * 40)
        job_sections = self._parse_job_analysis(job_analysis)

        # Limit to requested number of cover letters
        job_sections = job_sections[:num_letters]

        # Generate a cover letter for each job
        cover_letters = []
        for index, job_section in enumerate(job_sections, start=1):
            # Build the user prompt for this specific job
            user_prompt = USER_PROMPT.format(profile=profile, job_analysis=job_section)

            # Generate and format the cover letter document
            cover_letter = self._write_letters(
                system_prompt, user_prompt, letter_index=index
            )
            cover_letters.append(cover_letter)

        logger.info(f"Generated {len(cover_letters)} cover letter(s)")
        return cover_letters

    # ------------------------------
    # Internal functions
    # ------------------------------
    def _parse_job_analysis(self, job_analysis: str) -> List[str]:
        """Parse job analysis text to extract individual job sections.

        The job_analysis text contains multiple job analyses separated by
        delimiter lines (dashes). This function splits the text into
        individual job sections for separate cover letter generation.

        Each job section contains:
        - Title, Company, Location, Score
        - Matched Skills, Missing Skills
        - URL
        - Instructions (LLM-generated cover letter instructions)

        Args:
            job_analysis: Complete job analysis text with multiple jobs.
                Format: "Job Analysis\n===...\nTop X Jobs:\n\nTitle: ...\n...\n---\nTitle: ...\n..."

        Returns:
            List of job analysis strings, one per job. Each string contains
            the job details and instructions for that specific job, formatted
            for use in cover letter generation prompts.
        """
        # Split by common delimiter patterns used in analyzer
        # The analyzer uses "-" * 40 as separator between jobs
        delimiter = "-" * 40

        # Split the analysis into sections
        sections = job_analysis.split(delimiter)

        # Filter out empty sections and extract job data
        # The first section typically contains "Job Analysis" header and "Top X Jobs:"
        # Subsequent sections are individual jobs
        job_sections = []
        for idx, section in enumerate(sections):
            section = section.strip()
            # Skip empty sections
            if not section:
                continue

            # Process the first section (may contain header + first job)
            if idx == 0:
                lines = section.split("\n")
                # Find where actual job data starts (after "Top X Jobs:" line)
                start_idx = 0
                for i, line in enumerate(lines):
                    # Skip header lines
                    if "Job Analysis" in line or ("Top" in line and "Jobs:" in line):
                        start_idx = i + 1
                        continue
                    # If we hit a job data line, we've found the start
                    if "Title:" in line:
                        start_idx = i
                        break
                # Extract job content from this section
                remaining = "\n".join(lines[start_idx:]).strip()
                if remaining and (
                    "Title:" in remaining or "Instructions:" in remaining
                ):
                    job_sections.append(remaining)
            else:
                # Subsequent sections are individual jobs
                # Each section should contain: Title, Company, Location, Score, Skills, URL, Instructions
                if "Title:" in section or "Instructions:" in section:
                    job_sections.append(section)

        # If no sections found, treat entire analysis as single job (backward compatibility)
        if not job_sections:
            logger.warning("Could not parse job sections, treating as single job")
            # Remove header if present
            cleaned = job_analysis
            if "Job Analysis" in cleaned:
                lines = cleaned.split("\n")
                start_idx = 0
                for i, line in enumerate(lines):
                    if "Top" in line and "Jobs:" in line:
                        start_idx = i + 1
                        break
                cleaned = "\n".join(lines[start_idx:]).strip()
            if cleaned:
                job_sections.append(cleaned)

        logger.info(f"Parsed {len(job_sections)} job section(s) from analysis")
        return job_sections

    def _write_letters(
        self, system_prompt: str, user_prompt: str, letter_index: int = 1
    ) -> Document:
        """Create and format the cover letter Word document.

        Builds a professionally formatted business letter document with:
        1. Contact information placeholders (top-right)
        2. Current date (top-right)
        3. Recipient placeholders (top-right)
        4. LLM-generated cover letter body (main content)
        5. Signature placeholders (bottom-right)

        The document follows standard business letter formatting conventions.
        All placeholders (contact info, recipient, signature) should be filled
        in manually by the user before sending.

        Args:
            system_prompt (str): System prompt defining the LLM's role and
                writing style instructions for cover letter generation.
            user_prompt (str): User prompt containing candidate profile and
                job analysis with specific instructions for the cover letter.

        Returns:
            Document: python-docx Document object containing the complete
                formatted cover letter. The document is automatically saved
                to disk at {COVER_LETTER_PATH}/{timestamp}_cover_letter.docx
        """
        cover_letter = Document()

        # Add contact information section (top-right aligned)
        # Format: website, LinkedIn, GitHub (blank line) email, phone
        # Users should replace placeholders with their actual information
        contact_paragraph = cover_letter.add_paragraph()
        contact_paragraph.alignment = WD_ALIGN_PARAGRAPH.RIGHT
        contact_paragraph.add_run("ADD WEBSITE\n")
        contact_paragraph.add_run("ADD LINKEDIN\n")
        contact_paragraph.add_run("ADD GITHUB\n\n")
        contact_paragraph.add_run("ADD EMAIL\n")
        contact_paragraph.add_run("ADD PHONE\n\n")

        # Convert timestamp to human-readable date format
        # Input format: YYYYMMDD_HHMMSS (e.g., "20250115_143022")
        # Output format: "Month Day, Year" (e.g., "January 15, 2025")
        parsed_timestamp = datetime.strptime(self.timestamp, "%Y%m%d_%H%M%S")
        pretty_date = parsed_timestamp.strftime("%B %d, %Y")
        cover_letter.add_paragraph(f"{pretty_date}\n").alignment = (
            WD_ALIGN_PARAGRAPH.RIGHT
        )

        # Add recipient information placeholders (top-right aligned)
        # Users should fill in the actual recruiter/hiring team and company name
        cover_letter.add_paragraph("ADD RECRUITER/HIRING TEAM").alignment = (
            WD_ALIGN_PARAGRAPH.RIGHT
        )
        cover_letter.add_paragraph("ADD HIRING COMPANY/GROUP\n\n").alignment = (
            WD_ALIGN_PARAGRAPH.RIGHT
        )

        # Generate cover letter body content using LLM
        # The LLM writes personalized content based on profile and job analysis
        raw = call_llm(system_prompt, user_prompt, max_tokens=1500)
        # Normalize text: clean whitespace, line breaks, and formatting
        normalized = normalize_text(raw)
        # Insert the generated body into the document
        cover_letter.add_paragraph(normalized)

        # Add signature section (bottom-right aligned)
        cover_letter.add_paragraph("Best regards,").alignment = WD_ALIGN_PARAGRAPH.RIGHT
        cover_letter.add_paragraph("ADD YOUR NAME").alignment = WD_ALIGN_PARAGRAPH.RIGHT

        # Save document to disk for persistence and debugging
        # Include index in filename if generating multiple letters
        if letter_index > 1:
            filename = f"{self.timestamp}_cover_letter_{letter_index}.docx"
        else:
            filename = f"{self.timestamp}_cover_letter.docx"
        filepath = os.path.join(COVER_LETTER_PATH, filename)
        cover_letter.save(filepath)
        logger.info(f" Saved cover letter {letter_index} to {filepath}")

        return cover_letter
